**题目1：** 为什么要使用模块化？

最主要的目的：

解决命名冲突
依赖管理
其他价值

提高代码可读性
代码解耦，提高复用性

**题目2：** CMD、AMD、CommonJS 规范分别指什么？有哪些应用?

## AMD 规范

AMD (Asynchronous Module Definition, 异步模块定义) 指定一种机制，在该机制下模块和依赖可以移步加载。这对浏览器端的异步加载尤其适用。

由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎`RequireJS`，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出

requireJS主要解决两个问题

1. 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
2. js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

看一个使用requireJS的例子

```js
// 定义模块 myModule.js
define(['dependency'], function(){
    var name = 'Byron';
    function printName(){
        console.log(name);
    }

    return {
        printName: printName
    };
});

// 加载模块
require(['myModule'], function (my){
	my.printName(); 
});
```

## CMD:

CMD 即`Common Module Definition`通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同.

```js
// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js')
  $('div').addClass('active');
});

// 加载模块
seajs.use(['myModule.js'], function(my){

});　 
```

## CommonJS 规范

CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。

1. 在一个模块中，存在一个自由的变量”require”，它是一个函数。
   - 这个”require”函数接收一个模块标识符。
   - “require”返回外部模块所输出的API。
   - 如果出现依赖闭环(dependency cycle)，那么外部模块在被它的传递依赖（transitive dependencies）所require的时候可能并没有执行完成；在这种情况下，”require”返回的对象必须至少包含此外部模块在调用require函数（会进入当前模块执行环境）之前就已经准备完毕的输出。
   - 如果请求的模块不能返回，那么”require”必须抛出一个错误。
2. 在一个模块中，会存在一个名为”exports”的自由变量，它是一个对象，模块可以在执行的时候把自身的API加入到其中。
3. 模块必须使用”exports”对象来做为输出的唯一表示。

```js
//模块定义 myModel.js

var name = 'Byron';

function printName(){
    console.log(name);
}

module.exports = {
    printName: printName
}

//加载模块

var nameModule = require('./myModel.js');

nameModule.printName();
```

## 题目3

(预览)[https://hu970804.github.io/requirejs/]