## 1.引用类型有哪些？非引用类型有哪些

- 基本类型值（数值、布尔值、null和undefined、string）：指的是保存在栈内存中的简单数据段；
- 引用类型值（对象、数组、函数、正则）：指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象

## 2.如下代码输出什么？为什么?
```js
var obj1 = {a:1, b:2};
var obj2 = {a:1, b:2};
console.log(obj1 == obj2); //false ,obj1和obj2地址不同
console.log(obj1 = obj2);   //{a:1,b:2}，将obj2的地址赋值给obj1
console.log(obj1 == obj2); // true，两个地址相同
```


## 3.如下代码输出什么? 为什么

```js
var a = 1
var b = 2
var c = { name: '饥人谷', age: 2 }
var d = [a, b, c]

var aa = a
var bb = b
var cc = c
var dd = d

a = 11
b = 22
c.name = 'hello'
d[2]['age'] = 3

console.log(aa) //1  基本数据类型赋值给a，然后a赋值给aa
console.log(bb) //2  同上
console.log(cc) //{name: 'hello',age: 3}    c是一个object地址，c将object的地址赋值给cc，c.name的值改变，cc也会改变
console.log(dd) //[1,2,{name: 'hello',age: 3}]      d是一个 数组首地址，d将数组地址赋值给dd，d[2]['age']改变，dd也会改变
```

## 4.如下代码输出什么? 为什么

```js
var a = 1
var c = { name: 'jirengu', age: 2 }

function f1(n){
  ++n
}
function f2(obj){
  ++obj.age
}

f1(a) //a = 1，在fn1里面为2
f2(c) //{name : 'jirengu',age: 3}
f1(c.age) //c.age = 4
console.log(a) //1
console.log(c) //{name : 'jirengu',age: 4}
```

## 5.过滤如下数组，只保留正数，直接在原数组上操作

```js
var arr = [3,1,0,-1,-3,2,-5]
function filter(arr){
    for(var key = 0;key < arr.length;key++){
        if(arr[key] <= 0){
            arr.splice(key,1);
            key--;
        }
    }
}
filter(arr)
console.log(arr) // [3,1,2]
```

## 6.过滤如下数组，只保留正数，原数组不变，生成新数组

```js
var arr = [3,1,0,-1,-3,2,-5]
function filter(arr){
	var newArr = [];
	var j = 0;
	for(var i = 0;i < arr.length;i++){
		if (arr[i] > 0) {
			newArr[j] = arr[i];
			j++;
		}
	}
	return newArr;
}
var arr2 = filter(arr)
console.log(arr2) // [3,1,2]
console.log(arr)  // [3,1,0,-1,-2,2,-5]
```


## 7.写一个深拷贝函数，用两种方式实现

```js
//递归实现：
function deepCopy(obj) {
    var newObj = {};
    for(var key in obj){
        if(obj.hasOwnProperty(key)){
            if (typeof obj[key] === 'number' || typeof obj[key] === 'boolean' || typeof obj[key] === 'string' || obj[key] === undefined || obj[key] === null) {
                newObj[key] = obj[key]
            }else{
                newObj[key] = deepCopy(obj[key])
            }
        }
    }
    return newObj;
}


//json

function deepCopy(obj) {
    return JSON.parse(JSON.stringfy(obj));
}
```