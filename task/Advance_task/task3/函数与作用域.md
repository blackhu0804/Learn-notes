## 1. 函数声明和函数表达式有什么区别

函数声明使用function关键字生成一个函数。声明不必放到调用前面

```js
  //函数声明
  function sayHello(){
    console.log('hello')
  }

  //函数调用
  sayHello()
```

函数表达式，声明必须放到调用前面

```js
  var sayHello = function(){
    console.log('hello');
  }

  sayHello()
```


## 2. 什么是变量的声明前置？什么是函数的声明前置

- 变量的声明前置：
```js
//指在一个作用域块中，变量的声明会放在块的开始处
//var a
console.log(a); //不会报错而会输出undefined
var a = 3;
console.log(a); //3
```

- 函数的声明前置：

```js
//函数的声明前置是把整个函数提升到当前作用域的前面。
//输出hello
sayHello();

function sayHello(){
  console.log('hello');
}
```

## 3. arguments 是什么？

- arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。
- 在函数内部,你可以使用arguments对象获取到该函数的所有传入参数：
```js
  function printPersonInfo(name, age, sex){
    console.log(name);
    console.log(age);
    console.log(sex);
    console.log(arguments);
  }
```

## 4. 函数的"重载"怎样实现

> 在js中没有重载! 同名函数会覆盖。 但可以在函数体针对不同的参数调用执行相应的逻辑.

```js
  function printPeopleInfo(name, age, sex){
    if(name){
      console.log(name);
    }

    if(age){
      console.log(age);
    }

    if(sex){
      console.log(sex);
    }
  }


  printPeopleInfo('Byron', 26);
  printPeopleInfo('Byron', 26, 'male');
```

## 5. 立即执行函数表达式是什么？有什么作用

```js
//四种写法
(function() {/*code*/})();

(function fn1() {/*code*/}());
 
// 在数组初始化器内只能是表达式
[function fn2() {/*code*/}]();
 
// 逗号也只能操作表达式
1, function fn3() {/*code*/} ();
```
- 作用：隔离作用域

## 6. 求n!，用递归来实现

```js
function factor(n) {
    if(n <= 1)
        return 1;
    if(n > 1)
        return n * factor(n -1);
}

factor(5);

//120
```

## 7. 以下代码输出什么？

```js
function getInfo(name, age, sex){
		console.log('name:',name);
		console.log('age:', age);
		console.log('sex:', sex);
		console.log(arguments);
		arguments[0] = 'valley';
		console.log('name', name);
	}

    getInfo('饥人谷', 2, '男');
    //name: 饥人谷    age: 2    sex: 男;  ["饥人谷"，2, "男"]； name valley
    getInfo('小谷', 3);
    //name: 小谷      age: 2    sex: undefined  ["饥人谷"，2];  name valley
    getInfo('男');
    //name: 男    age: undefined    sex: undefined    ["饥人谷"]；　　name valley
```

## 8. 写一个函数，返回参数的平方和？

```js
   function sumOfSquares(){
       var result = 0;
       for(var i = 0;i < arguments.length;i++){
           result += arguments[i] * arguments[i];
       }
       return result;
   }
   var result = sumOfSquares(2,3,4)
   var result2 = sumOfSquares(1,3)
   console.log(result)  //29
   console.log(result2)  //10
```

## 9. 如下代码的输出？为什么
```js
	console.log(a); //undefined ,变量声明前置
	var a = 1;
	console.log(b); //b is not defined
```

## 10. 如下代码的输出？为什么

```js
    sayName('world');
	sayAge(10);
	function sayName(name){
		console.log('hello ', name);
	}
	var sayAge = function(age){
		console.log(age);
	};
    //hello world 函数声明前置
    //sayAge is not a function 函数表达式不前置
```

## 11. 如下代码输出什么? 写出作用域链查找过程伪代码

```js
    var x = 10
    bar() 
    function foo() {
    console.log(x)
    }
    function bar(){
    var x = 30
    foo()
    }

    //output：10    

    /*

        1.
        globalContext = {
            AO： {
                x： 10,
                bar: function
                foo: function
            },
            scope:bull
        },
        foo.[[scope]] = globalContext.AO
        bar.[[scope]] = globalContext.AO

        2.bar
        barContext = {
            AO: {
                x: 30
            },
            scope:globalContext.AO
        }

        3.foo
        fooContext = {
            AO: {}
            scope:globalContext.AO
        }
    */
```

## 12. 如下代码输出什么? 写出作用域链查找过程伪代码

```js
var x = 10;
bar() 
function bar(){
  var x = 30;
  function foo(){
    console.log(x) 
  }
  foo();
}	

//output：30

/*

1.
globalContext{
    AO: {
        x: 10;
        bar: function
    },
}
bar.[[scope]] = globalContext.AO

2.bar
barContext {
    AO : {
        x: 30
        foo: function
    },
}
    foo.[[scope]] = barContext

3.foo
fooContext {
    AO: {}
    scope = barContext.AO
}

*/
```

## 13. 以下代码输出什么? 写出作用域链的查找过程伪代码

```js
var x = 10;
bar() 
function bar(){
  var x = 30;
  (function (){
    console.log(x)
  })()
}

//output:30

/*

1.
globalContext{
    AO: {
        x: 10;
        bar: function
    },
}
bar.[[scope]] = globalContext.AO

2.
barContext {
    AO : {
        x: 30
        foo: function
    },
}
    foo.[[scope]] = barContext

3.foo
fooContext {
    AO: {}
    scope = barContext.AO
}

*/
```

## 14.以下代码输出什么？ 写出作用域链查找过程伪代码

```js
var a = 1;

function fn(){
  console.log(a)
  var a = 5
  console.log(a)
  a++
  var a
  fn3()
  fn2()
  console.log(a)

  function fn2(){
    console.log(a)
    a = 20
  }
}

function fn3(){
  console.log(a)
  a = 200
}

fn()
console.log(a)

//output:undefined  5   1   6   20  200

/*

1.
globalContext = {
    AO: {
        a : 1,
        fn: function,
        fn3: function
    }
}

fn.[[scope]]:globalContext.AO
fn3.[[scope]]:globalContext.AO

2.
fnContext = {
    AO: {
        a: 5,
        fu2: function
    }
    scope:globalContext.AO
}

fn2.[[scope]].fnContext.AO

3.
fn3Context = {
  AO: {

  },
  scope:globalCOntext.AO
}

4.
fn2Context = {
  AO: {},
  scope: globalContext.AO
}


*/
```